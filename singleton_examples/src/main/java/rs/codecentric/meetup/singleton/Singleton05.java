package rs.codecentric.meetup.singleton;

/**
 * Double-checked locking.
 */
public class Singleton05 {

    private static Singleton05 instance = null;

    private Singleton05() {
        // Do nothing.
    }

    // 1. Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
    //
    // 2. The code generated by the compiler is allowed to update the shared variable to
    // point to a partially constructed object before A has finished performing the initialization.
    //
    // 3. Thread B notices that the shared variable has been initialized (or so it appears),
    // and returns its value. Because thread B believes the value is already initialized, it does not acquire the lock.
    // If B uses the object before all of the initialization done by A is seen by B the program will likely crash.
    public static Singleton05 getInstance() {
        if (instance == null) {
            synchronized (Singleton05.class) {
                if (instance == null) {
                    instance = new Singleton05();
                }
            }
        }
        return instance;
    }

    // Memory model problems prior to Java 5?

}
